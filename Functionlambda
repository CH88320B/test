using System;
using System.Collections.Generic;
using System.Net;
using Amazon.Lambda.APIGatewayEvents;
using Amazon.Lambda.Core;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System.Xml;

// Assembly attribute to enable the Lambda function's JSON input to be converted into a .NET class.
[assembly: LambdaSerializer(typeof(Amazon.Lambda.Serialization.SystemTextJson.DefaultLambdaJsonSerializer))]

namespace EH.Shared.SdocJsonToXpmConverterLambda
{
    public class Function
    {
        public APIGatewayProxyResponse FunctionHandler(APIGatewayProxyRequest request, ILambdaContext context)
        {
            var sdocxpm = request.Body;
            var serializedXpm = string.Empty;

            bool isEncounter = false;
            bool isSDoc_Root = false;

            if (Is_JSON(sdocxpm))
            {
                var json = JObject.Parse(sdocxpm);
                isEncounter = json.ContainsKey("Encounter");
                isSDoc_Root = json.ContainsKey("SDoc_Root");
            }
            else if (Is_XML(sdocxpm))
            {
                XmlDocument xmlDoc = new XmlDocument();
                xmlDoc.LoadXml(sdocxpm);
                isEncounter = xmlDoc.SelectSingleNode("//Encounter") != null;
                isSDoc_Root = xmlDoc.SelectSingleNode("//SDoc_Root") != null;
            }

            LambdaLogger.Log("is - before");

            if (isSDoc_Root)
            {
                bool IsdocJson = Is_JSON(sdocxpm);
                bool IsdocXml = Is_XML(sdocxpm);

                if (Is_JSON(sdocxpm))
                {
                    Console.WriteLine("IS Json");
                }
                else if (Is_XML(sdocxpm))
                {
                    Console.WriteLine("IS XML");
                }

                if (request.Headers != null && request.Headers.TryGetValue("Content-Type", out var contentType))
                {
                    LambdaLogger.Log("is - Test");

                    if (string.Equals(contentType, "application/json", StringComparison.OrdinalIgnoreCase))
                    {
                        LambdaLogger.Log("is - SDocJsonToXpm Mapper");
                    }
                }

                if (IsdocJson == true)
                {
                    serializedXpm = JsonConvert.SerializeObject(RootMapper.Map(sdocxpm, "application/json"));
                }
                else
                {
                    serializedXpm = JsonConvert.SerializeObject(RootMapper.Map(sdocxpm, "application/xml"));
                }

                LambdaLogger.Log("Complete - SDocJsonToXpm Mapper");
            }
            else if (isEncounter)
            {
                LambdaLogger.Log("Beginning - Encounter Mapper");
                try
                {
                    var intermidieclass = JsonConvert.DeserializeObject<XpmRoot>(sdocxpm);
                    var rootClass = intermidieclass?.Adapt<XpmRoot>();

                    var fisrtencounter = rootClass?.Encounter[0];
                    var mapperSdoc = new SdocMappingConfig();
                    var sdoRoot = mapperSdoc.MapXpmtoSdoc(fisrtencounter);
                    serializedXpm = JsonConvert.SerializeObject(sdoRoot);
                }
                catch (Exception ex)
                {
                    context.Logger.LogLine($"Error: {ex.Message}, StackTrace: {ex.StackTrace}");

                    var errorObject = new
                    {
                        error = $"Errors:{ex.Message}",
                        trace = ex.StackTrace
                    };

                    serializedXpm = JsonConvert.SerializeObject(errorObject);

                    return new APIGatewayProxyResponse
                    {
                        StatusCode = 400,
                        Body = serializedXpm,
                        Headers = new Dictionary<string, string>
                        {
                            { "Content-Type", "application/json" },
                            { "Access-Control-Allow-Origin", "*" }
                        }
                    };
                }
            }

            return new APIGatewayProxyResponse
            {
                StatusCode = (int)HttpStatusCode.OK,
                Body = serializedXpm,
                Headers = new Dictionary<string, string>
                {
                    { "Content-Type", "application/json" },
                    { "Access-Control-Allow-Origin", "*" }
                }
            };
        }

        static bool Is_JSON(string sdocxpm)
        {
            try
            {
                Newtonsoft.Json.JsonConvert.DeserializeObject(sdocxpm);
                return true;
            }
            catch (Exception)
            {
                return false;
            }
        }

        static bool Is_XML(string sdocxpm)
        {
            try
            {
                XmlDocument xmlDoc = new XmlDocument();
                xmlDoc.LoadXml(sdocxpm);
                return true;
            }
            catch (Exception)
            {
                return false;
            }
        }
    }
}
